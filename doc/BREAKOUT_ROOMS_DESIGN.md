# ブレイクアウトルーム対応の設計案検討

最終更新日: 2024 年

## 📋 提案された機能構成

### ① 計測モード（ブレイクアウトルーム側）

**目的**: ブレイクアウトルーム内の話者データを計測・保存

**動作フロー**:

1. ブレイクアウトルームでアプリを起動
2. 初期入力:
   - 打ち合わせ名（例：ミーティング名）
   - ブレイクアウトルーム名（手入力 or 選択）
3. 「計測開始」ボタン押下
4. Zoom SDK を利用して話者データを取得
5. 状態を一定間隔（例：10 秒）で DB に保存
6. 計測終了 or ブレイクアウト終了時: 最終状態を DB に保存

**依存**:

- Zoom Apps SDK：必須（話者データ取得のため）
- Backend / DB：必須（永続化・共有のため）

**補足**:

- 各ブレイクアウトルームで起動したアプリは独立
- 他ルームの状態は一切見えない
- ブレイクアウト解散後に UI 操作はできないため、途中経過も定期保存する

### ② ホスト閲覧モード（ホスト側）

**目的**: 各ブレイクアウトルームの計測状況を一覧表示

**動作フロー**:

1. ホストがアプリを起動
2. 「ホスト閲覧モード」ボタンを押下
3. DB から各ルームの最新状態を取得
4. 一定間隔（例：10 秒）で再取得して画面更新

**依存**:

- Zoom Apps SDK：必須ではない
- Backend / DB：必須

**ポイント**:

- Zoom SDK で他ルームを覗いているわけではない
- 単に外部 DB をポーリングして表示しているだけ
- Zoom のブレイクアウト制約には一切抵触しない

### データ連携の考え方

- **各計測アプリ（ブレイクアウト側）**: 自分の状態を DB に書く
- **ホスト閲覧モード**: DB を 10 秒ごとに読む
- **結果**: 最大 10 秒遅れの「準リアルタイム」表示を実現

---

## ✅ 現実性の評価

### 総合評価: ✅ **非常に現実的**

この提案は技術的に実現可能で、Zoom の制約にも適合しています。

### 1. 技術的実現可能性

| 項目                       | 評価    | 理由                                                                                                       |
| -------------------------- | ------- | ---------------------------------------------------------------------------------------------------------- |
| **各ルームでの独立動作**   | ✅ 可能 | Zoom Apps SDK の`getMeetingParticipants()`は現在のルームの参加者のみを返すため、各ルームで独立して動作可能 |
| **DB への定期保存**        | ✅ 可能 | REST API でバックエンドに送信するだけなので、実装が簡単                                                    |
| **ホストの DB ポーリング** | ✅ 可能 | ホストは Zoom SDK を使わず、単に DB を読むだけなので、制約に抵触しない                                     |
| **10 秒間隔の更新**        | ✅ 可能 | `setInterval`で簡単に実装可能                                                                              |

### 2. Zoom の制約への適合性

| 制約                                   | 適合性  | 理由                                                                             |
| -------------------------------------- | ------- | -------------------------------------------------------------------------------- |
| **ブレイクアウトルームのプライバシー** | ✅ 適合 | 各ルームは自分のデータのみを DB に書き込む。他ルームのデータに直接アクセスしない |
| **ホストの他ルーム閲覧**               | ✅ 適合 | Zoom SDK を使わず、外部 DB を読むだけなので、Zoom の制約に抵触しない             |
| **リアルタイム性**                     | ✅ 適合 | 10 秒遅れは許容範囲内。必要に応じて WebSocket で改善可能                         |

### 3. 実装の複雑度

| 項目                   | 複雑度 | 備考                                       |
| ---------------------- | ------ | ------------------------------------------ |
| **計測モード**         | 🟢 低  | 既存の実装を拡張するだけ                   |
| **DB 保存機能**        | 🟡 中  | バックエンド API の実装が必要              |
| **ホスト閲覧モード**   | 🟢 低  | DB からデータを取得して表示するだけ        |
| **認証・セキュリティ** | 🟡 中  | ミーティング ID やルーム ID での認証が必要 |

---

## 🔧 修正可能性の検討

### 改善可能な点

#### 1. 初期入力の自動化（推奨）

**現状の提案**: 手入力

**改善案**: 可能な限り自動取得

```typescript
// 改善案: Zoom SDKから自動取得を試みる
const meetingInfo = await zoomSdk.getMeetingInfo();
const meetingName = meetingInfo.topic || meetingInfo.meetingNumber;

// ブレイクアウトルーム名も自動取得を試みる
const currentRoom = await zoomSdk.getCurrentBreakoutRoom();
const roomName = currentRoom?.name || "手入力が必要";
```

**実現可能性**: ⚠️ **部分的に可能**

- ミーティング名: Zoom SDK で取得できる可能性が高い
- ブレイクアウトルーム名: SDK が提供するかどうか要確認
- フォールバック: 取得できない場合は手入力にフォールバック

#### 2. 更新間隔の調整

**現状の提案**: 10 秒固定

**改善案**: 設定可能にする

```typescript
// 改善案: 設定可能な更新間隔
const UPDATE_INTERVAL = {
  FAST: 5000, // 5秒（リアルタイム重視）
  NORMAL: 10000, // 10秒（バランス）
  SLOW: 30000, // 30秒（負荷軽減）
};
```

**実現可能性**: ✅ **可能** - 簡単に実装可能

#### 3. WebSocket によるリアルタイム化（オプション）

**現状の提案**: 10 秒ごとのポーリング

**改善案**: WebSocket でリアルタイム更新

```typescript
// 改善案: WebSocketでリアルタイム更新
const ws = new WebSocket("wss://your-backend.com/ws");
ws.onmessage = (event) => {
  const updatedStats = JSON.parse(event.data);
  // 即座に画面更新
};
```

**実現可能性**: ✅ **可能** - バックエンドの実装が必要
**メリット**: 遅延が 1 秒以下に短縮可能
**デメリット**: バックエンドの複雑度が増加

#### 4. ホスト判定の自動化

**現状の提案**: 「ホスト閲覧モード」ボタンを押下

**改善案**: ホストかどうかを自動判定

```typescript
// 改善案: Zoom SDKでホスト判定
const userInfo = await zoomSdk.getCurrentUser();
const isHost = userInfo.role === "host";

if (isHost) {
  // 自動的にホスト閲覧モードを表示
} else {
  // 計測モードを表示
}
```

**実現可能性**: ✅ **可能** - Zoom SDK でホスト判定が可能

#### 5. データの永続化とエクスポート

**追加提案**: 各ルームで結果をダウンロード

```typescript
// 追加機能: 各ルームで結果をダウンロード
function exportRoomData(roomId: string) {
  // DBからデータを取得
  const stats = await fetch(`/api/rooms/${roomId}/stats`);
  // CSV/JSON形式でダウンロード
  downloadFile(stats, `room-${roomId}-stats.csv`);
}
```

**実現可能性**: ✅ **可能** - 既に検討済みの機能

---

## 📊 実装アーキテクチャ

### データフロー図

```
┌─────────────────────────────────────────┐
│  ブレイクアウトルーム1                 │
│  ┌───────────────────────────────────┐ │
│  │ 計測モード                        │ │
│  │ - 参加者データ取得（Zoom SDK）    │ │
│  │ - 10秒ごとにDBに保存              │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
           │
           │ POST /api/rooms/{roomId}/stats
           │ (10秒ごと)
           ▼
┌─────────────────────────────────────────┐
│  バックエンドサーバー + DB             │
│  ┌───────────────────────────────────┐ │
│  │ PostgreSQL / MongoDB              │ │
│  │ - 各ルームの統計データを保存      │ │
│  │ - タイムスタンプ付き              │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
           │
           │ GET /api/rooms/stats
           │ (10秒ごと)
           ▼
┌─────────────────────────────────────────┐
│  メインルーム（ホスト）                 │
│  ┌───────────────────────────────────┐ │
│  │ ホスト閲覧モード                  │ │
│  │ - DBから全ルームのデータを取得    │ │
│  │ - 10秒ごとに更新                  │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

### データベーススキーマ（提案）

```sql
-- ミーティングテーブル
CREATE TABLE meetings (
  id UUID PRIMARY KEY,
  meeting_name VARCHAR(255) NOT NULL,
  zoom_meeting_id VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW(),
  ended_at TIMESTAMP
);

-- ブレイクアウトルームテーブル
CREATE TABLE breakout_rooms (
  id UUID PRIMARY KEY,
  meeting_id UUID REFERENCES meetings(id),
  room_name VARCHAR(255) NOT NULL,
  room_number INTEGER,
  created_at TIMESTAMP DEFAULT NOW(),
  ended_at TIMESTAMP
);

-- 統計データテーブル
CREATE TABLE room_stats (
  id UUID PRIMARY KEY,
  room_id UUID REFERENCES breakout_rooms(id),
  participant_id VARCHAR(255) NOT NULL,
  display_name VARCHAR(255),
  speaking_count INTEGER DEFAULT 0,
  total_speaking_ms BIGINT DEFAULT 0,
  is_speaking BOOLEAN DEFAULT FALSE,
  last_started_speaking_at TIMESTAMP,
  recorded_at TIMESTAMP DEFAULT NOW()
);

-- インデックス
CREATE INDEX idx_room_stats_room_id ON room_stats(room_id);
CREATE INDEX idx_room_stats_recorded_at ON room_stats(recorded_at);
```

---

## 🎯 実装優先順位

### Phase 1: 基本機能（必須）

1. ✅ **計測モードの実装**

   - 初期入力画面（ミーティング名、ルーム名）
   - 計測開始ボタン
   - Zoom SDK でのデータ取得
   - 10 秒ごとの DB 保存

2. ✅ **バックエンド API の実装**

   - POST `/api/rooms/{roomId}/stats` - 統計データの保存
   - GET `/api/rooms/stats` - 全ルームの統計データ取得
   - データベースの設計と実装

3. ✅ **ホスト閲覧モードの実装**
   - ホスト判定（手動 or 自動）
   - DB からのデータ取得
   - 10 秒ごとの更新
   - 全ルームの一覧表示

### Phase 2: 改善機能（推奨）

4. 🔧 **初期入力の自動化**

   - ミーティング名の自動取得
   - ブレイクアウトルーム名の自動取得（可能な場合）

5. 🔧 **ホスト判定の自動化**

   - Zoom SDK でのホスト判定
   - 自動的にモードを切り替え

6. 🔧 **エクスポート機能**
   - 各ルームでの結果ダウンロード
   - CSV/JSON 形式でのエクスポート

### Phase 3: 高度な機能（オプション）

7. ⚡ **WebSocket によるリアルタイム化**

   - バックエンドに WebSocket サーバーを追加
   - リアルタイム更新（1 秒以下）

8. ⚡ **更新間隔の設定**
   - ユーザーが更新間隔を選択可能
   - 5 秒/10 秒/30 秒など

---

## ⚠️ 注意事項とリスク

### 1. データの整合性

**リスク**: 複数のルームが同時にデータを書き込む場合の競合

**対策**:

- データベースのトランザクションを使用
- タイムスタンプベースの更新
- 楽観的ロックの実装

### 2. 認証とセキュリティ

**リスク**: 不正なアクセスやデータ改ざん

**対策**:

- ミーティング ID とルーム ID での認証
- JWT トークンによる認証
- HTTPS 通信の必須化

### 3. パフォーマンス

**リスク**: 多数のルームがある場合の負荷

**対策**:

- データベースのインデックス最適化
- キャッシュの活用（Redis）
- 更新間隔の調整

### 4. データの保持期間

**リスク**: データベースの容量増加

**対策**:

- データの保持期間を設定（例：30 日）
- 自動削除機能の実装
- アーカイブ機能の実装

---

## 📝 結論

### 現実性: ✅ **非常に現実的**

- 技術的に実現可能
- Zoom の制約に適合
- 実装の複雑度が適切
- 段階的な実装が可能

### 修正可能性: ✅ **高い**

- 初期入力の自動化が可能
- 更新間隔の調整が可能
- WebSocket によるリアルタイム化が可能
- ホスト判定の自動化が可能

### 推奨事項

1. **Phase 1 を優先的に実装**: 基本機能を先に実装し、動作確認を行う
2. **初期入力は手入力から開始**: 自動化は後から追加する
3. **10 秒間隔は適切**: リアルタイム性と負荷のバランスが良い
4. **WebSocket はオプション**: まずはポーリングで実装し、必要に応じて WebSocket を追加

### 総合評価

**この提案は非常に現実的で、実装可能です。** Zoom の制約にも適合しており、段階的な実装が可能です。まずは Phase 1 を実装し、動作確認を行った後、Phase 2 の改善機能を追加することを推奨します。
